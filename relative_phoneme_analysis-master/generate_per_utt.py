import sys
import os
import re

def convert_align_to_per_utt(input_filepath, output_filepath, alignment_symbol='***'):
    """
    Converts the output of Kaldi's align-text into the standard per_utt format.

    Args:
        input_filepath (str): Path to the input file generated by align-text.
                              Format: utt_id ref1 hyp1 ; ref2 hyp2 ; ...
        output_filepath (str): Path to the output file to be created.
                               Format:
                               utt_id ref word1 word2 ...
                               utt_id hyp word1 word2 ...
                               utt_id op   C   S   I   ...
                               utt_id #csid C S I D
        alignment_symbol (str): The symbol used by align-text for insertions/deletions.
                                Defaults to '***'.
    """
    print(f"Starting conversion: {input_filepath} -> {output_filepath}")
    lines_processed = 0
    errors_encountered = 0

    # --- Ensure the output directory exists before opening files ---
    output_dir = os.path.dirname(output_filepath)
    if output_dir and not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir)
            print(f"Created output directory: {output_dir}")
        except OSError as e:
            print(f"Error creating output directory {output_dir}: {e}", file=sys.stderr)
            return # Exit if directory creation fails

    try:
        with open(input_filepath, 'r', encoding='utf-8') as infile, \
             open(output_filepath, 'w', encoding='utf-8') as outfile:

            for line_num, line in enumerate(infile, 1):
                line = line.strip()
                if not line:
                    continue # Skip empty lines

                parts = line.split(maxsplit=1)
                if len(parts) < 2:
                    print(f"Warning: Skipping malformed line {line_num}: '{line}' - No alignment pairs found.", file=sys.stderr)
                    errors_encountered += 1
                    continue

                utt_id = parts[0]
                alignment_str = parts[1]

                ref_words = []
                hyp_words = []
                op_codes = []
                counts = {'C': 0, 'S': 0, 'I': 0, 'D': 0}

                # Split alignment string into pairs based on ' ; '
                aligned_pairs_str = alignment_str.split(' ; ')

                for pair_str in aligned_pairs_str:
                    pair_str = pair_str.strip()
                    if not pair_str:
                        continue # Skip empty pairs if they occur

                    # Split each pair into ref and hyp words
                    word_pair = pair_str.split(maxsplit=1) # Use maxsplit=1 in case words contain spaces (unlikely but safer)

                    # Handle potential parsing errors within a pair
                    if len(word_pair) == 2:
                        ref_word, hyp_word = word_pair
                    elif len(word_pair) == 1:
                        # This might happen if align-text outputs only one word for a pair (unusual)
                        # Decide how to handle: assume deletion/insertion or skip? Let's assume skip for now.
                        print(f"Warning: Skipping malformed pair '{pair_str}' in utt {utt_id} (line {line_num}).", file=sys.stderr)
                        errors_encountered += 1
                        continue
                    else: # Should not happen with maxsplit=1, but good to handle
                         print(f"Warning: Skipping unexpected pair format '{pair_str}' in utt {utt_id} (line {line_num}).", file=sys.stderr)
                         errors_encountered += 1
                         continue

                    # Determine operation and update counts/lists
                    if ref_word == alignment_symbol: # Insertion
                        op = 'I'
                        counts['I'] += 1
                        ref_words.append(alignment_symbol) # Keep alignment symbol in ref/hyp lines
                        hyp_words.append(hyp_word)
                    elif hyp_word == alignment_symbol: # Deletion
                        op = 'D'
                        counts['D'] += 1
                        ref_words.append(ref_word)
                        hyp_words.append(alignment_symbol) # Keep alignment symbol in ref/hyp lines
                    elif ref_word == hyp_word: # Correct
                        op = 'C'
                        counts['C'] += 1
                        ref_words.append(ref_word)
                        hyp_words.append(hyp_word)
                    else: # Substitution
                        op = 'S'
                        counts['S'] += 1
                        ref_words.append(ref_word)
                        hyp_words.append(hyp_word)

                    op_codes.append(op)

                # Write the 4 lines for this utterance to the output file
                outfile.write(f"{utt_id} ref {' '.join(ref_words)}\n")
                outfile.write(f"{utt_id} hyp {' '.join(hyp_words)}\n")
                outfile.write(f"{utt_id} op {' '.join(op_codes)}\n")
                outfile.write(f"{utt_id} #csid {counts['C']} {counts['S']} {counts['I']} {counts['D']}\n")
                lines_processed += 1

    except FileNotFoundError:
        print(f"Error: Input file not found at {input_filepath}", file=sys.stderr)
        return
    except Exception as e:
        print(f"An unexpected error occurred: {e}", file=sys.stderr)
        return

    print(f"Conversion finished.")
    print(f"Processed {lines_processed} utterances.")
    if errors_encountered > 0:
        print(f"Encountered {errors_encountered} warnings/errors during processing. Please check stderr output.")
    print(f"Output written to: {output_filepath}")

# --- Configuration ---
# Define the base path for your project in the JupyterLab environment
# Use os.path.expanduser to handle '~' correctly
project_base = os.path.expanduser('~/Onedrive/Bureaublad/relative_phoneme_analysis-master')
output_base = os.path.join(project_base, 'kaldi_formatted_output', 'large2')

# --- Paths for Dutch group (large-v2) ---
input_file_nl = os.path.join(output_base, 'per_utt_aligned_nl_large2.txt')
output_file_nl = os.path.join(output_base, 'per_utt_final_nl_large2.txt')

# --- Paths for French group (large-v2) ---
input_file_fr = os.path.join(output_base, 'per_utt_aligned_fr_large2.txt')
output_file_fr = os.path.join(output_base, 'per_utt_final_fr_large2.txt')

# --- Run the conversion for both groups ---
print("\n--- Processing Dutch Group (large-v3) ---")
convert_align_to_per_utt(input_file_nl, output_file_nl)

print("\n--- Processing French Group (large-v3) ---")
convert_align_to_per_utt(input_file_fr, output_file_fr)

print("\nScript finished.")
